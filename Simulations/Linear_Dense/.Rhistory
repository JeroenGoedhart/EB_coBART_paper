p = ggplot(LearningCurve1, aes(x = ntrain, y = IPI)) +
geom_point(size=3) + coord_cartesian(ylim = c(0,1)) +
geom_line(linewidth=0.8) +
theme_light() +
labs(x="Training set size",y="IPI weight") +
scale_color_manual(values="#3DB4ADFF")
p
p = ggplot(LearningCurve1, aes(x = ntrain, y = IPI)) +
geom_point(size=3) + coord_cartesian(ylim = c(0,1)) +
geom_line(linewidth=0.8) +
theme_light() +
labs(x="Training set size",y="IPI weight") +
scale_color_manual(values="#3DB4ADFF")
p
p = ggplot(LearningCurve1, aes(x = ntrain, y = IPI)) +
geom_point(size=3,col="#3DB4ADFF") + coord_cartesian(ylim = c(0,1)) +
geom_line(linewidth=0.8) +
theme_light() +
labs(x="Training set size",y="IPI weight") +
scale_color_manual(values="#3DB4ADFF")
p
p = ggplot(LearningCurve1, aes(x = ntrain, y = IPI)) +
geom_point(size=3,col="#3DB4ADFF") + coord_cartesian(ylim = c(0,1)) +
geom_line(linewidth=0.8,col="#3DB4ADFF") +
theme_light() +
labs(x="Training set size",y="IPI weight") +
scale_color_manual(values="#3DB4ADFF")
p
install.packages(c("BART", "cobalt"))
load("C:/Users/VNOB-0732/Desktop/R files/Files_for_Jeroen/Clinical_and_Molecular_Data_Combined.Rdata")
View(dat)
load("C:/Users/VNOB-0732/Desktop/R files/Files_for_Jeroen/AllRelevantData.Rdata")
View(WorkingData)
remove(dat)
# selecting 1 treatment
dat <- WorkingData
remove(WorkingData)
dat$Main_treatment
ids <- which(dat$Main_treatment=="RCHOP")
ids <- which(dat$Main_treatment=="RChop")
datRChop <- dat[ids,]
### dichotomizing PFS outcome to  2yrs: yes or no
RespPFS <- cbind(datRChop$PFS_days,datRChop$PFS_STAT)
id <- which(RespPFS[,2]==0 & RespPFS[,1] < 365*2) #remove censored observations before 2yrs
RespBinary <- RespPFS[-id,1]
RespBinary <-ifelse(RespBinary > 365*2,0,1)
summary(RespBinary)
id <- which(RespPFS[,2]==0 & RespPFS[,1] < 365*5) #remove censored observations before 2yrs
### dichotomizing PFS outcome to  2yrs: yes or no
RespPFS <- cbind(datRChop$PFS_days,datRChop$PFS_STAT)
id <- which(RespPFS[,2]==0 & RespPFS[,1] < 365*5) #remove censored observations before 2yrs
RespBinary <- RespPFS[-id,1]
RespBinary <-ifelse(RespBinary > 365*2,0,1)
summary(RespBinary)
datRChop <- datRChop[-id,]
datRChop$PFS_dich <-RespBinary
remove(dat,id,ids)
datRChop1 = subset(datRChop, select = -c(PFS_days,PFS_STAT,Main_treatment))
datRChop1$transMYC[datRChop1$transMYC6==3] <- 1
View(datRChop1)
Mutations = datRChop1[,68:137]
for (i in 1:ncol(Mutations)) {
Mutations[,i][Mutations[,i]==2]<-1
}
datRChop1[,68:137] <- Mutations
dat <- datRChop1
library('stringr')
colnames(dat) <- str_replace_all(colnames(dat),'','_')
colnames(dat)
View(dat)
dat$transMYC[dat$transMYC==3]<-1
dat$transMYC[dat$transBCL2==3]<-1
load("AllRelevantData.Rdata")
load("C:/Users/VNOB-0732/Desktop/R files/Files_for_Jeroen/AllRelevantData.Rdata")
# selecting 1 treatment
dat <- WorkingData
remove(WorkingData)
dat$Main_treatment
ids <- which(dat$Main_treatment=="RChop")
datRChop <- dat[ids,]
### dichotomizing PFS outcome to  2yrs: yes or no
RespPFS <- cbind(datRChop$PFS_days,datRChop$PFS_STAT)
id <- which(RespPFS[,2]==0 & RespPFS[,1] < 365*5) #remove censored observations before 2yrs
RespBinary <- RespPFS[-id,1]
RespBinary <-ifelse(RespBinary > 365*2,0,1)
summary(RespBinary)
datRChop <- datRChop[-id,]
datRChop$PFS_dich <-RespBinary
remove(dat,id,ids)
datRChop1 = subset(datRChop, select = -c(PFS_days,PFS_STAT,Main_treatment))
dat$transMYC[dat$transMYC==3]<-1
dat$transBCL2[dat$transBCL2==3]<-1
datRChop1$transMYC[datRChop1$transMYC==3]<-1
datRChop1$transBCL2[datRChop1$transBCL2==3]<-1
datRChop1$transBCL6[datRChop1$transBCL6==3]<-1
Mutations = datRChop1[,68:137]
for (i in 1:ncol(Mutations)) {
Mutations[,i][Mutations[,i]==2]<-1
}
datRChop1[,68:137] <- Mutations
dat <- datRChop1
library('stringr')
colnames(dat) <- str_replace_all(colnames(dat),'','_')
colnames(dat) <- str_replace_all(colnames(dat),'-','_')
colnames(dat)
file = "ClinOmLymphomaApplication.Rdata"
getwd()
save(dat, file = file)
library(Matrix)
SplitVariables <- function(Tree,Z) {
rules = unlist(Rules(Tree,leafonly = T)$path)
Vars <- lapply(colnames(Z), function (x) sum(grepl(x,unlist(rules))))
names(Vars) <- colnames(Z)
Vars <- unlist(Vars,use.names = T)
ids = which(Vars==0)
}
Dat_Tree <- function(tree,X,Z,Y, idVars=0) {
#convert data to right format for regressions: X <- diag(X_node1,X_node2, .....,X_nodeNodeNum)
#                                              Y <- (Y_node1,Y_node2, .....,Y_nodeNodeNum)
# tree: fit of regression tree
# X: omics covariate design matrix (intercept (=column with 1's) included)
# Z: clinical covariate matrix (used for tree fitting, so no intercept required!)
# Y: response vector (should be same length as nrow(X))
# idVars: Clinical variables not included in tree, will be modeled linearly
nodes <-  row.names(tree$frame)[rpart.predict.leaves(tree,Z)]
nodes <- as.numeric(nodes)
names = paste0("N",sort(unique(nodes)))
p = ncol(X)
if (is.null(colnames(X))){colnames(X) = paste0("x",seq(1,p))}
namesX = colnames(X)
NumNodes <- length(unique(nodes))
X_nodes = vector("list", length = NumNodes)
Y_nodes = c()
EmptyNodes <- c()
Intercepts <- c()
for (i in 1:NumNodes) {
node = sort(unique(nodes))[i]
ids = which(nodes==node)
Intercepts <- append(Intercepts,nodes[ids])
if (length(ids)==0)
{EmptyNodes <- append(EmptyNodes,i)}
else if (length(ids)==1)
{X_nodes[[i]] <- matrix(X[ids,],nrow = 1,ncol = p+1)}
else {X_nodes[[i]] = X[ids,]}
Y_nodes <- append(Y_nodes,Y[ids])
remove(ids,node)
colnames(X_nodes[[i]]) <- paste0(names[i],paste0("_",namesX))
}
#X_tot <- Reduce(adiag,X_nodes)
X_tot <- bdiag(X_nodes)
# organize X such that omics variable in all nodes are next to each other
X_tot1 <- c()
for (i in 1:p) {
ids = seq(i,p*NumNodes,p)
X_tot1 <- cbind(X_tot1,X_tot[,ids])
}
Intercepts1 = model.matrix(~0+factor(Intercepts))
names = paste0("N",sort(unique(nodes)))
Intercepts1 <- as.matrix(cbind(Intercepts1,Z[,idVars]))
colnames(Intercepts1)[1:length(unique(nodes))] = names
return(list(U=Intercepts1,X=X_tot, X1 = X_tot1, Y=Y_nodes,EmptyNodes = EmptyNodes)) #list with X: omics covariates; Y: response
}
PenMatr <- function(NumNodes,p){
# NumNodes: total number of leaf nodes
# p: total number of omics covariates (or covariates which are regressed in the nodes)
#Lambda = diag(1,nrow=p*NumNodes, ncol=p*NumNodes)
Omega = matrix(0,nrow=p*NumNodes, ncol=p*NumNodes)
diag(Omega) <- 1/NumNodes
if (NumNodes==1){return(Omega)}
else{
for (i in 1:(NumNodes-1)) {
Ncol = i*p
diag(Omega[-(1:Ncol),]) <- 1/NumNodes
diag(Omega[,-(1:Ncol)]) <- 1/NumNodes
}
Omega1 <- diag(1,nrow=p*NumNodes, ncol=p*NumNodes)-Omega
}
return(Omega1) # NumNodes(p+1) x Numnodes(p+1) matrix (+1 to include intercept)
}
PenMatr2 <- function(NumNodes,p){
block=diag(1,nrow = NumNodes,ncol = NumNodes)-1/NumNodes*matrix(1,nrow = NumNodes,ncol = NumNodes)
#Omega=kronecker(diag(p), block)
blocks <- replicate(p, block,simplify=FALSE)
#Omega = diag(p) %x% block
Omega <- bdiag(blocks)
return(Omega)
}
EigPenmatr <- function(NumNodes,p){
Eig_base = eigen(PenMatr2(NumNodes,1))$vectors
Eigvecs = c()
for(i in 1:NumNodes){
Eigvecs = cbind(Eigvecs,Matrix::kronecker(Diagonal(p,1),Eig_base[,i]))
}
diags= c(rep(1,p*(NumNodes-1)),rep(0,p))
return(list(values=diags,vectors=Eigvecs))
}
library(porridge)
library(penalized)
library(magic)
library(rpart);
library(rpart.plot)
library(treeClust)
library(multiridge)
library(ModTools)
library(caret)
library(xgboost)
p = 500
p_Clin = 4
N = 300
Ntest = 1000
g <- function (z,x,betas){
1*(z[,1] <= -1)*(-10 + x[,1:250] %*% betas[1:250]*10) +
1*(z[,1] > -1)*1*(z[,3] <= -0.12)*(7.5 + x[,1:250]%*% betas[1:250]*1) +
1*(z[,1] > -1)*1*(z[,3] > -0.12)*1*(z[,4] > 0.22)*(-4 + x[,1:250]%*% betas[1:250]*0.2) +
1*(z[,1] > -1)*1*(z[,3] > -0.12)*1*(z[,4] <= -0.12)*(1 + x[,1:250]%*% betas[1:250]*0.1) +
x[,251:500]%*% betas[251:500]
}
set.seed(2)
betas<- rnorm(p,mean = 0, sd = 0.1)
Z = matrix(rnorm(N*p_Clin,0,1),nrow = N, ncol = p_Clin)
colnames(Z) = paste0("z",seq(1,p_Clin))
Z <- data.frame(Z)
## simulating omics covariates
#set.seed(i*3+4*i^2+3)
X = matrix(rnorm(N*p,0,1),nrow = N, ncol = p)
colnames(X) = paste0("x",seq(1,p))
## simulating response
#set.seed(i*3+4*i^2+3)
Y = g(z = Z, x = X, betas=betas)[,1] + rnorm(N,0,1)
####### 1. Fit Reg Tree ######
dat=cbind.data.frame(Y,Z)
# fitting tree
rp <- rpart(Y~.,data = dat, control = rpart.control(xval =10, minbucket = 15),
model = T)
cp = rp$cptable[,1][which.min(rp$cptable[,4])]
Treefit <- prune(rp, cp = 0.016)
prp(Treefit,extra=1)
#idsVar = SplitVariables(Tree = Treefit, Z= data.frame(Z))
remove(dat,rp)
####### 4. Fit fully FusedReg Tree ######
Nodes <-  row.names(Treefit$frame)[rpart.predict.leaves(Treefit,Z)]
Nodes <- as.numeric(Nodes)
Dat=Dat_Tree(X=X,Z=Z,Y=Y, tree = Treefit, idVars = 0)
X <- Dat$X1; Y <- Dat$Y; U <- Dat$U
####### 5. Fit  FusedReg Tree ######
Delta = PenMatr2(NumNodes = length(unique(Treefit$where)), p = p)
dim(X)
lambda=1; lambdaG=1
mat = lambdaG*PenMatr2(NumNodes,1)+Diagonal(NumNodes,lambda)
NumNodes = length(which(Delta[1,]!=0)); p=ncol(Delta)/NumNodes
mat = lambdaG*PenMatr2(NumNodes,1)+Diagonal(NumNodes,lambda)
Dg1 <- Matrix::kronecker(Diagonal(p,1),solve(mat)) %*%t(X)
dim(X)
Dg2          <- qr.solve(diag(rep(lambda, ncol(X))) +
lambdaG * Delta, t(X),
tol=.Machine$double.eps)
dim(Dg1)
dim(Dg2)
Dg1 <- as.matrix(Dg1)
all.equal(Dg1,Dg2)
system.time(Matrix::kronecker(Diagonal(p,1),solve(mat)) %*% t(X))
system.time(qr.solve(diag(rep(lambda, ncol(X))) +
lambdaG * Delta, t(X),
tol=.Machine$double.eps))
Dg1 <- tcrossprod(Matrix::kronecker(Diagonal(p,1),solve(mat)), X)
Dg2          <- qr.solve(diag(rep(lambda, ncol(X))) +
lambdaG * Delta, t(X),
tol=.Machine$double.eps)
dim(Dg1)
dim(Dg2)
Dg1 <- as.matrix(Dg1)
all.equal(Dg1,Dg2)
rep(matrix(1,nrow=2,ncol=2),1)
replicate(matrix(1,nrow=2,ncol=2),1)
replicate(matrix(1,nrow=2,ncol=2),2)
replicate(2,matrix(1,nrow=2,ncol=2))
.PenMatr <- function(NumNodes,p){
block=diag(1,nrow = NumNodes,ncol = NumNodes)-1/NumNodes*matrix(1,nrow = NumNodes,ncol = NumNodes)
#Omega=kronecker(diag(p), block)
blocks <- replicate(p, block,simplify=FALSE)
#Omega = diag(p) %x% block
Omega <- bdiag(blocks)
return(Omega)
}
.EigPenmatr <- function(NumNodes,p){
Eig_base = eigen(.PenMatr(NumNodes,1))$vectors
Eigvecs = c()
for(i in 1:NumNodes){
Eigvecs = cbind(Eigvecs,Matrix::kronecker(Diagonal(p,1),Eig_base[,i]))
}
diags= c(rep(1,p*(NumNodes-1)),rep(0,p))
return(list(values=diags,vectors=Eigvecs))
}
a=.PenMatr(4,4)
library(Matrix)
a=.PenMatr(4,4)
a=as.matrix(.PenMatr(4,4))
View(a)
Eig_base = eigen(.PenMatr(NumNodes,1))$vectors
Eig_base = eigen(.PenMatr(4,1))$vectors
View(Eig_base)
Eig_base_rep = replicate(4,Eig_base)
Eig_base_rep = replicate(4,Eig_base,simplify = F)
Eig_base_rep = bdiag(Eig_base_rep)
Eig_base_rep = as.matrix(bdiag(Eig_base_rep))
Eig = eigen(.PenMatr(4,1))
Vecs = Eig$vectors
Vals = Eig$values
Vals
Vals = c(rep(1,4-1),0)
Vals <- rep(Vals,4)
Vals
Eig_base_rep %*% Diagonal(Vals) %*% t(Eig_base_rep)
Eig_base_rep %*% diag(Vals) %*% t(Eig_base_rep)
a1 <- Eig_base_rep %*% diag(Vals) %*% t(Eig_base_rep)
all.equal(a,a1)
dim(Matrix::kronecker(Diagonal(4,1),Vecs))
.PenMatr <- function(NumNodes,p){
block=diag(1,nrow = NumNodes,ncol = NumNodes)-1/NumNodes*matrix(1,nrow = NumNodes,ncol = NumNodes)
#Omega=kronecker(diag(p), block)
blocks <- replicate(p, block,simplify=FALSE)
#Omega = diag(p) %x% block
Omega <- bdiag(blocks)
return(Omega)
}
library(Matrix)
.EigPenmatr <- function(NumNodes,p){
Eig_base = eigen(.PenMatr(NumNodes,1))$vectors
Eigvecs = Matrix::kronecker(Diagonal(p,1),Eig_base)
diags = rep(c(rep(1,NumNodes-1),0),p)
#Eigvecs = c()
#for(i in 1:NumNodes){
#  Eigvecs = cbind(Eigvecs,Matrix::kronecker(Diagonal(p,1),Eig_base[,i]))
#}
#diags= c(rep(1,p*(NumNodes-1)),rep(0,p))
return(list(values=diags,vectors=Eigvecs))
}
a = as.matrix(.PenMatr(4,4))
Eigs = .EigPenmatr(4,4)
a1= Eigs$vectors%*%diag(Eigs$values)%*% t(Eigs$vectors)
all.equal(a,a1)
a1= as.matrix(Eigs$vectors%*%diag(Eigs$values)%*% t(Eigs$vectors))
all.equal(a,a1)
a = as.matrix(.PenMatr(4,500))
Eigs = .EigPenmatr(4,500)
a1= as.matrix(Eigs$vectors%*%diag(Eigs$values)%*% t(Eigs$vectors))
all.equal(a,a1)
a = as.matrix(.PenMatr(10,500))
Eigs = .EigPenmatr(10,500)
a1= as.matrix(Eigs$vectors%*%diag(Eigs$values)%*% t(Eigs$vectors))
all.equal(a,a1)
.CVfolds <- function(Y,model=NULL,balance=TRUE,kfold=5,fixedfolds=TRUE,nrepeat=1){ #response is required for balanced CV
#response: response vector, length n
#model: "logistic", "cox", etc
#balance: should the splits balance levels of the response?
#kfold: scalar, the number of folds
#fixedfolds: should the folds be fixed? (for reproducibility)
#nrepeat: number of repeats of the CV
#Output: list object with kfold elements containing the sample indices of the left-out samples per fold
if(is.null(model)){
if(is(Y,"Surv")) model <- "cox" else {
model <- ifelse(length(unique(Y)) ==2, "logistic","linear")
}
}
response <- Y
if(model=="linear") balance <- FALSE
CVfoldsrep <- function(rep){
nsam <- length(response)
if (fixedfolds) set.seed(3534+rep-1) #else set.seed(NULL)  #changed 19/4
if (!balance) {
rand <- sample(1:nsam)
grs1 <- floor(nsam/kfold)
grs2 <- grs1 + 1
ngr1 <- kfold * grs2 - nsam
folds <- lapply(1:kfold, function(xg) {
if (xg <= ngr1)
els <- rand[(1 + (xg - 1) * grs1):(xg * grs1)]
else els <- rand[(ngr1 * grs1 + 1 + (xg - ngr1 -
1) * grs2):(ngr1 * grs1 + (xg - ngr1) * grs2)]
return(sort(els))
})
}
else {
if (model == "logistic")
if (is(response,"factor"))
nev <- which((as.numeric(response) - 1) == 1)
else nev <- which(response == 1)
if (model == "cox") nev <- which(response[, 2] == 1)
nsamev <- length(nev)
randev <- sample(nev)
grs1 <- floor(nsamev/kfold)
grs2 <- grs1 + 1
ngr1 <- kfold * grs2 - nsamev
foldsev <- lapply(1:kfold, function(xg) {
if (xg <= ngr1)
els <- randev[(1 + (xg - 1) * grs1):(xg * grs1)]
else els <- randev[(ngr1 * grs1 + 1 + (xg - ngr1 -
1) * grs2):(ngr1 * grs1 + (xg - ngr1) * grs2)]
return(els)
})
nonev <- setdiff(1:nsam, nev)
nsamnonev <- length(nonev)
randnonev <- sample(nonev)
grs1 <- floor(nsamnonev/kfold)
grs2 <- grs1 + 1
ngr1 <- kfold * grs2 - nsamnonev
foldsnonev <- lapply(1:kfold, function(xg) {
if (xg <= ngr1)
els <- randnonev[(1 + (xg - 1) * grs1):(xg *
grs1)]
else els <- randnonev[(ngr1 * grs1 + 1 + (xg - ngr1 -
1) * grs2):(ngr1 * grs1 + (xg - ngr1) * grs2)]
return(els)
})
folds <- lapply(1:kfold, function(i) sort(c(foldsev[[i]],
foldsnonev[[i]])))
}
return(folds)
}
return(unlist(lapply(1:nrepeat,CVfoldsrep),recursive=FALSE))
}
Y=rnorm(5)
folds = .CVfolds(Y)
length(Y) > folds
folds
Y=rnorm(500)
folds = .CVfolds(Y)
length(Y) > folds
Y=rnorm(500)
folds = .CVfolds(Y)
folds
class(folds)
inherits(folds)
inherits(folds, what = class)
inherits(folds, "integer")
inherits(folds, "numeric")
a=folds[[1]]
inherits(folds, "int")
class(a)
inherits(folds, "integer")
inherits(folds, integer)
lapply(folds,class)
unlist(lapply(folds,class))
unlist(lapply(folds,class)) != "integer"
all(unlist(lapply(folds,class)) != "integer")
all(!(unlist(lapply(folds,class)) == "integer" || unlist(lapply(folds,class)) == "numeric")
all(!(unlist(lapply(folds,class)) == "integer" || unlist(lapply(folds,class)) == "numeric"))
all(!(unlist(lapply(folds,class)) == "integer" || unlist(lapply(folds,class)) == "numeric"))
if(!all(unlist(lapply(folds,class)) == "integer" | unlist(lapply(folds,class)) == "numeric")){stop("a")}
folds=5
if(!all(unlist(lapply(folds,class)) == "integer" | unlist(lapply(folds,class)) == "numeric")){stop("a")}
folds="5"
if(!all(unlist(lapply(folds,class)) == "integer" | unlist(lapply(folds,class)) == "numeric")){stop("a")}
Y = rnorm(500)
folds = .CVfolds(Y)
unlist(folds) > Y
if(!all(unlist(folds) > length(Y))){stop("fold id out of range")}
unlist(folds) > length(Y))
unlist(folds) > length(Y)
if(!all(unlist(folds) =< length(Y))){stop("fold id out of range")}
if(!all(unlist(folds) <= length(Y))){stop("fold id out of range")}
a=1
length(a)
library(installr)
updateR()
######### DART #########
########################
setwd("C:/Users/VNOB-0732/Desktop/R files/EB_coBART_paper/Simulations/Linear_Dense")
N = 200
N = 100
Ntest = 500
p = 500
sigma = 1
load("betas_for_sim.Rdata")
library(mvtnorm)
set.seed(12)
Xtest <- rmvnorm(Ntest, mean = rep(0, p), #sigma = CorrX,
method= "chol", pre0.9_9994 = FALSE, checkSymmetry = TRUE)
Ytest <- Xtest %*% betas1 + rnorm(Ntest, mean = 0, sd = sigma)
probs <- c(rep(1/p,p))
k =2; base = .95; power = 2.0 # Tree parameters
nu <- 10 ; quant <- .75 # Error variance hyperparameters
nrep <-500
nchain = 10
theta = ncol(Xtest)
nrep <- 500
library(BART)
PMSEstest <- c()
for (j in 1:nrep){    # for loop representing simulated data sets
print(paste("Sim","Iter",j,sep = " "))
# simulate training data, either setting 1 or setting 2
set.seed(j^3+239)
X <- rmvnorm(N, mean = rep(0, p), #sigma = CorrX,
method= "chol", pre0.9_9994 = FALSE, checkSymmetry = TRUE)
Y <- X %*% betas1 + rnorm(N, 0, sigma)
sigest <- sd(Y)*0.667
pred_sBART = matrix(NA,nrow=nchain,ncol = nrow(Xtest))
for (i in 1:nchain) {
fit = wbart(x.train = X, y.train = Y, x.test = Xtest,
base = base, power = power, k = k,
ntree = 50,
ndpost = 5000L,   # number of posterior samples
nskip = 5000L, # number of "warmup" samples to discard
sparse = T, theta = theta,printevery =10000)
pred_sBART[i,] <- fit$yhat.test.mean
remove(fit)
}
preds <- colMeans(pred_sBART)
PMSEstest[j] <- mean((preds-Ytest)^2)
remove(X,Y,preds)
}
mean(PMSEstest)
